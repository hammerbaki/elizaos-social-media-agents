<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Agents Performance Hub</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; margin-bottom: 5px; }
        .subtitle { text-align: center; color: #666; font-size: 1.1em; margin-top: 0; margin-bottom: 20px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .stat-card { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; color: #007bff; }
        .stat-label { color: #666; margin-top: 5px; }
        
        /* 차트 레이아웃 */
        .chart-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .chart-single {
            margin: 30px 0;
            display: flex;
            justify-content: center;
        }
        
        #platformChart {
            max-width: 600px;
        }
        
        #timelineChart {
            min-height: 500px;
        }
        
        .refresh-btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; }
        .refresh-btn:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>AI Agents Performance Hub</h1>
        <p class="subtitle">Twitter • Discord • Telegram</p>
        <button class="refresh-btn" onclick="loadData()">Refresh Data</button>
        <div class="stats" id="stats"></div>
        
        <!-- 1. Platform Pie Chart (단독) -->
        <div class="chart-single">
            <div id="platformChart"></div>
        </div>
        
        <!-- 2. Timeline Chart (단독) -->
        <div class="chart-single">
            <div id="timelineChart"></div>
        </div>
        
        <!-- 3. Response Time Distribution + Violin Plot (나란히) -->
        <div class="chart-row">
            <div id="responseTimeChart"></div>
            <div id="violinChart"></div>
        </div>
        
        <!-- 4. Scatter Plot + Trend Lines Chart (나란히) -->
        <div class="chart-row">
            <div id="scatterChart"></div>
            <div id="trendChart"></div>
        </div>
    </div>

    <script>
    // 전역 색상 정의 (Plotly 기본 색상)
    const platformColors = {
        'twitter': '#1f77b4',    // 파란색
        'discord': '#ff7f0e',    // 주황색  
        'telegram': '#2ca02c'    // 초록색
    };

    function loadData() {
        fetch('all_platforms_performance.csv')
            .then(response => response.text())
            .then(csvText => {
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        updateDashboard(results.data);
                    }
                });
            });
    }

    function updateDashboard(data) {
        // Remove empty rows and system platform data
        data = data.filter(row => row.timestamp && row.platform !== 'system');
        
        // Calculate statistics
        const stats = {
            total: data.length,
            avgResponseTime: data.reduce((acc, row) => acc + (row.response_time_ms || 0), 0) / data.length,
            platforms: {}
        };
        
        // Group by platform
        data.forEach(row => {
            if (!stats.platforms[row.platform]) {
                stats.platforms[row.platform] = { count: 0, totalTime: 0 };
            }
            stats.platforms[row.platform].count++;
            stats.platforms[row.platform].totalTime += row.response_time_ms || 0;
        });
        
        // Update stats cards
        document.getElementById('stats').innerHTML = `
            <div class="stat-card">
                <div class="stat-value">${stats.total.toLocaleString()}</div>
                <div class="stat-label">Total Interactions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${stats.avgResponseTime.toFixed(2)}ms</div>
                <div class="stat-label">Avg Storage Time</div>
            </div>
            ${['twitter', 'discord', 'telegram']
                .filter(platform => stats.platforms[platform])
                .map(platform => {
                    const data = stats.platforms[platform];
                    return `
                        <div class="stat-card">
                            <div class="stat-value">${data.count.toLocaleString()}</div>
                            <div class="stat-label">${platform.toUpperCase()}</div>
                        </div>
                    `;
                }).join('')}
        `;
        
        // 1. Platform pie chart (단독)
        const orderedPlatforms = ['twitter', 'discord', 'telegram']
            .filter(platform => stats.platforms[platform]);
            
        const platformData = [{
            values: orderedPlatforms.map(platform => stats.platforms[platform].count),
            labels: orderedPlatforms,
            type: 'pie',
            sort: false,
            marker: {
                colors: orderedPlatforms.map(p => platformColors[p])
            },
            textinfo: 'percent',
            texttemplate: '%{percent:.1%}',
            hovertemplate: '%{label}<br>%{percent:.1%}<br>%{value} interactions<extra></extra>'
        }];
        
        Plotly.newPlot('platformChart', platformData, {
            title: 'Interactions by Platform',
            width: 600,
            height: 400
        });
        
        // 2. Timeline chart with rangeslider (단독)
        const timelineData = ['twitter', 'discord', 'telegram']
            .filter(platform => stats.platforms[platform])
            .map((platform, index) => ({
            x: data.filter(row => row.platform === platform).map(row => row.timestamp),
            y: data.filter(row => row.platform === platform).map(row => row.response_time_ms),
            mode: 'markers',
            type: 'scatter',
            name: platform,
            marker: { 
                size: 4,
                color: platformColors[platform]
            }
        }));
        
        Plotly.newPlot('timelineChart', timelineData, {
            title: 'Storage Time Over Time',
            xaxis: { 
                title: 'Date',
                type: 'date',
                rangeslider: { visible: true }
            },
            yaxis: { 
                title: 'Storage Time (ms)',
                range: [0, 250]
            },
            height: 500,
            width: 1300 
        });
        
        // 3. Response time distribution
        const responseTimeData = [{
            x: data.map(row => row.response_time_ms),
            type: 'histogram',
            name: 'StorageTime Distribution',
            xbins: { size: 5 },
            marker: { color: '#007bff' }
        }];
        
        Plotly.newPlot('responseTimeChart', responseTimeData, {
            title: 'Storage Time Distribution',
            xaxis: { title: 'Storage Time (ms)', range: [0, 200] },
            yaxis: { title: 'Count' },
            width: 600,
            height: 400
        });

        // 4. 플랫폼별 응답시간 분포 (Violin Plot)
        const violinData = ['twitter', 'discord', 'telegram'].map((platform, index) => ({
            y: data.filter(row => row.platform === platform)
                   .map(row => row.response_time_ms),
            type: 'violin',
            name: platform,
            box: {
                visible: true
            },
            meanline: {
                visible: true
            },
            marker: { color: platformColors[platform] }
        }));

        Plotly.newPlot('violinChart', violinData, {
            title: 'Storage Time Distribution Density by Platform',
            yaxis: { 
                title: 'Storage Time (ms)',
                range: [0, 250]
            },
            width: 600,
            height: 400
        });

        // 5. 메시지 길이 vs 응답시간 산점도
        const platforms = ['twitter', 'discord', 'telegram'];
        const scatterData = platforms.map((platform, index) => {
            const platformData = data.filter(row => row.platform === platform);
            return {
                x: platformData.map(row => row.message_length),
                y: platformData.map(row => row.response_time_ms),
                mode: 'markers',
                type: 'scatter',
                name: platform,
                marker: {
                    color: platformColors[platform],
                    size: 4,
                    opacity: 0.6
                }
            };
        });

        Plotly.newPlot('scatterChart', scatterData, {
            title: 'Message Length vs Storage Time by Platform',
            xaxis: { 
                title: 'Message Length (characters)',
                range: [0, 3500]
            },
            yaxis: { 
                title: 'Storage Time (ms)',
                range: [0, 250]
            },
            legend: {
                x: 1,      // 0.02에서 1로 변경 (오른쪽)
                y: 1,      // 0.98에서 1로 변경 (위쪽)
                xanchor: 'right',
                yanchor: 'top',
                bgcolor: 'rgba(255,255,255,0.8)'
            },
            width: 600,
            height: 500
        });

        // 6. 추세선만 표시하는 새로운 차트
        const trendData = [];
        
        platforms.forEach((platform, index) => {
            const platformData = data.filter(row => row.platform === platform);
            const x = platformData.map(row => row.message_length);
            const y = platformData.map(row => row.response_time_ms);
            
            if (x.length > 1) {
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                const trendX = [0, 3500];
                const trendY = trendX.map(xi => slope * xi + intercept);
                
                trendData.push({
                    x: trendX,
                    y: trendY,
                    mode: 'lines',
                    type: 'scatter',
                    name: platform,
                    line: {
                        color: platformColors[platform],
                        width: 1.5
                    }
                });
                
                // 추세선 방정식 텍스트 추가
                const equation = `y = ${slope.toFixed(4)}x + ${intercept.toFixed(2)}`;
                trendData.push({
                    x: [1750],
                    y: [slope * 1750 + intercept],
                    mode: 'text',
                    type: 'scatter',
                    text: [equation],
                    textposition: 'top',
                    textfont: {
                        color: platformColors[platform],
                        size: 12
                    },
                    showlegend: false
                });
            }
        });

        Plotly.newPlot('trendChart', trendData, {
            title: 'Storage Time Trend Lines by Platform',
            xaxis: { 
                title: 'Message Length (characters)',
                range: [0, 3500]
            },
            yaxis: { 
                title: 'Storage Time (ms)',
                range: [0, 250]
            },
            width: 600,
            height: 500
        });
    }
    
    // Load data on page load
    loadData();
    
    // Auto-refresh every 30 seconds
    setInterval(loadData, 30000);
    </script>
</body>
</html>