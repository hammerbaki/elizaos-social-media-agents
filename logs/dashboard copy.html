<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ElizaOS Performance Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .stat-card { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; color: #007bff; }
        .stat-label { color: #666; margin-top: 5px; }
        #charts > div { margin: 20px 0; }
        .refresh-btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; }
        .refresh-btn:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ElizaOS Performance Dashboard</h1>
        <button class="refresh-btn" onclick="loadData()">Refresh Data</button>
        <div class="stats" id="stats"></div>
        <div id="charts">
            <div id="responseTimeChart"></div>
            <div id="platformChart"></div>
            <div id="timelineChart"></div>
        </div>
    </div>

    <script>
    function loadData() {
        fetch('all_platforms_performance.csv')
            .then(response => response.text())
            .then(csvText => {
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        updateDashboard(results.data);
                    }
                });
            });
    }

    function updateDashboard(data) {
        // Remove empty rows
        data = data.filter(row => row.timestamp);
        
        // Calculate statistics
        const stats = {
            total: data.length,
            avgResponseTime: data.reduce((acc, row) => acc + (row.response_time_ms || 0), 0) / data.length,
            platforms: {}
        };
        
        // Group by platform
        data.forEach(row => {
            if (!stats.platforms[row.platform]) {
                stats.platforms[row.platform] = { count: 0, totalTime: 0 };
            }
            stats.platforms[row.platform].count++;
            stats.platforms[row.platform].totalTime += row.response_time_ms || 0;
        });
        
        // Update stats cards
        document.getElementById('stats').innerHTML = `
            <div class="stat-card">
                <div class="stat-value">${stats.total.toLocaleString()}</div>
                <div class="stat-label">Total Interactions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${stats.avgResponseTime.toFixed(2)}ms</div>
                <div class="stat-label">Avg Response Time</div>
            </div>
            ${['twitter', 'discord', 'telegram', 'system']
                .filter(platform => stats.platforms[platform])
                .map(platform => {
                    const data = stats.platforms[platform];
                    return `
                        <div class="stat-card">
                            <div class="stat-value">${data.count.toLocaleString()}</div>
                            <div class="stat-label">${platform.toUpperCase()}</div>
                        </div>
                    `;
                }).join('')}
        `;
        
        // Response time distribution
        const responseTimeData = [{
            x: data.map(row => row.response_time_ms),
            type: 'histogram',
            name: 'Response Time Distribution',
            xbins: { size: 5 }
        }];
        
        Plotly.newPlot('responseTimeChart', responseTimeData, {
            title: 'Response Time Distribution',
            xaxis: { title: 'Response Time (ms)' },
            yaxis: { title: 'Count' }
        });
        
        // Platform pie chart
        const orderedPlatforms = ['twitter', 'discord', 'telegram', 'system']
            .filter(platform => stats.platforms[platform]);
            
        const platformData = [{
            values: orderedPlatforms.map(platform => stats.platforms[platform].count),
            labels: orderedPlatforms,
            type: 'pie',
            sort: false  // 자동 정렬 비활성화
        }];
        
        Plotly.newPlot('platformChart', platformData, {
            title: 'Interactions by Platform'
        });
        
        // Timeline chart
        const timelineData = ['twitter', 'discord', 'telegram', 'system']
            .filter(platform => stats.platforms[platform])
            .map(platform => ({
            x: data.filter(row => row.platform === platform).map(row => row.timestamp),
            y: data.filter(row => row.platform === platform).map(row => row.response_time_ms),
            mode: 'markers',
            type: 'scatter',
            name: platform
        }));
        
        Plotly.newPlot('timelineChart', timelineData, {
            title: 'Response Time Over Time',
            xaxis: { title: 'Time' },
            yaxis: { title: 'Response Time (ms)' }
        });
    }

    // Load data on page load
    loadData();
    
    // Auto-refresh every 30 seconds
    setInterval(loadData, 30000);
    </script>
</body>
</html>
